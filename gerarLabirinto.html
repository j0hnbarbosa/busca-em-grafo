<script>
// Inicializar matriz.
const inicializaMatriz = (tamanho) => {
  return new Array(tamanho).fill(null).map(() => new Array(tamanho).fill(0));
}

const gerarPosicao = (vlr) => {
  return Math.floor(Math.random() * vlr);
}

const gerarLabirinto = () => {

  let labirinto = inicializaMatriz(10);
  console.log(labirinto);

  const tamLabirinto = labirinto.length;
  const inicioRow = gerarPosicao(tamLabirinto);
  const inicioCol = gerarPosicao(tamLabirinto);

  labirinto[inicioRow][inicioCol] = 2;
  
  let novoCaminhoRow = inicioRow;
  let novoCaminhoCol = inicioCol;;
  // Usado para verificar os arredores da posição atual para verificar se a posição é valida
  const rowX = [0, 1, 0, -1];
  const colY = [1, 0, -1, 0];
  
  let acabouCaminhos = false;
  
  let posVerifica = gerarPosicao(4);

  const pilha = [];
  pilha.push({row: inicioRow, col: inicioCol});
  
  let posAleatorio = Array(4).fill(0);

  let chamaPilhaFlag = false;
  
while(pilha.length > 0) {

  while(posAleatorio.indexOf(0) != -1) {
  posVerifica = gerarPosicao(4);

  if(posAleatorio[posVerifica] == 0) {
    posAleatorio[posVerifica] = 1;
  }
  // Gera primeiro passo
  if (novoCaminhoRow + rowX[posVerifica] >= 0 && novoCaminhoRow + rowX[posVerifica] < tamLabirinto 
  && novoCaminhoCol + colY[posVerifica] >= 0 && novoCaminhoCol + colY[posVerifica] < tamLabirinto
  && labirinto[ novoCaminhoRow + rowX[posVerifica] ][ novoCaminhoCol + colY[posVerifica] ] == 0
  ) {
    
    labirinto[ novoCaminhoRow + rowX[posVerifica] ][ novoCaminhoCol + colY[posVerifica] ] = 4;
    novoCaminhoRow = novoCaminhoRow + rowX[posVerifica];
    novoCaminhoCol = novoCaminhoCol + colY[posVerifica];
    posAleatorio = Array(4).fill(0);
    break;
  }

  if( posAleatorio.indexOf(0) == -1 ) {
    chamaPilhaFlag = true;
  }

}  

  while(posAleatorio.indexOf(0) != -1) {
    posVerifica = gerarPosicao(4);

    if(posAleatorio[posVerifica] == 0) {
      posAleatorio[posVerifica] = 1;
    }

    // Gera segundo passo
    if (novoCaminhoRow + rowX[posVerifica] >= 0 && novoCaminhoRow + rowX[posVerifica] < tamLabirinto 
    && novoCaminhoCol + colY[posVerifica] >= 0 && novoCaminhoCol + colY[posVerifica] < tamLabirinto
    && labirinto[ novoCaminhoRow + rowX[posVerifica] ][ novoCaminhoCol + colY[posVerifica] ] == 0
    ) {
      
      labirinto[ novoCaminhoRow + rowX[posVerifica] ][ novoCaminhoCol + colY[posVerifica] ] = 5;
      novoCaminhoRow = novoCaminhoRow + rowX[posVerifica];
      novoCaminhoCol = novoCaminhoCol + colY[posVerifica];
      pilha.unshift({row: novoCaminhoRow, col: novoCaminhoCol});
      posAleatorio = Array(4).fill(0);
      break;
    }
    if( posAleatorio.indexOf(0) == -1 ) {
      chamaPilhaFlag = true;
    }
  }

  if( chamaPilhaFlag ) {
    chamaPilhaFlag=false;
    novoCaminhoRow = pilha[0].row;
    novoCaminhoCol = pilha[0].col;
    pilha.shift();
    console.table(pilha[0]);
    posAleatorio = Array(4).fill(0);
  }
}
console.table(pilha);

console.log(labirinto);
}
gerarLabirinto();
</script>